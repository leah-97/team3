<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>위쪽 반원 드래그 회전(가운데정렬 고정)</title>
    <style>
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }
      body {
        min-height: 100vh;
        background: #fafafa;
        font-family: system-ui, Segoe UI, Arial;
        display: flex;
        flex-direction: column;
        align-items: center;
        position: relative;
      }
      h2 {
        color: #ff0000;
        font-size: 3rem;
        margin: 24px 0 8px;
      }

      /* 보이는 시야(반원) 영역 */
      .product_wrap {
        position: relative; /* ⬅️ relative로 기준 고정 */
        width: 100vw;
        height: 60vh; /* 시야 높이(늘리면 더 보임) */
        overflow: hidden;
        margin: 300px auto; /* 섹션 자체도 가운데 */
        touch-action: none;
        user-select: none;
        /* 필요하면 섹션을 전체 페이지에서 위로/아래로 이동 */
        /* margin-top: 8vh;  */
      }

      /* 거대한 원: width/height는 JS에서 설정. margin:auto로 수평 중앙 고정 */
      .product_slide {
        position: relative; /* ⬅️ absolute 제거 */
        margin: 0 auto; /*⬅️ 가로 중앙 (width가 픽셀로 있으니 정확히 중앙)*/
        /* margin-left: -10px; */
        border-radius: 50%;
        /* 세로 위치는 JS에서 margin-top으로 제어 */
        transform: translateX(-80px);
      }

      /* 카드(상품) */
      .product_slide > div {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 40rem; /* 카드 폭(사진 크기) */
        display: flex;
        flex-direction: column;
        align-items: center;
        transition: transform 0.08s ease;
      }
      .photo {
        width: 100%;
      }
      .photo img {
        width: 100%;
        display: block;
        pointer-events: none;
      }
      .info {
        display: none;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 30rem;
        height: 30rem;
        background-color: rgba(255, 255, 255, 0.5);
        border-radius: 1rem;
        z-index: 10;

        /* 중앙 정렬 설정 */
        /* display: flex; */
        flex-direction: column; /* 세로 방향으로 정렬 */
        justify-content: center; /* 세로축 가운데 */
        align-items: center; /* 가로축 가운데 */
        text-align: center; /* 텍스트 중앙정렬 */
      }

      .info h3 {
        font-size: 3rem;
        text-align: center;
        margin: 100px 0px 100px 0px;
      }
      .info p {
        font-weight: bold;
        font-size: 1.5rem;
        text-align: center;
      }

      .product_slide > div:hover .info {
        display: flex; /* or block — 내부 정렬 필요 시 flex */
        justify-content: center;
        align-items: center;
      }

      @media (max-width: 768px) {
        .product_wrap {
          height: 55vh;
        }
        .product_slide > div {
          width: 18rem;
        }
      }
    </style>
  </head>
  <body>
    <h2>Product</h2>

    <div class="product_wrap" id="wrap">
      <div class="product_slide" id="wheel">
        <div>
          <div class="photo">
            <img src="img/초코파이 찰떡 누끼.png" alt="초코파이 찰떡" />
          </div>
          <div class="info">
            <h3>초코파이 찰떡</h3>
            <p>달콤한 초콜릿과 부드러운 쿠키속에 찰떡이 들어있는 초코파이</p>
          </div>
        </div>
        <div>
          <div class="photo">
            <img src="img/찰떡쿠키.png" alt="찰떡쿠키 오리지널" />
          </div>
          <div class="info">
            <h3>찰떡쿠키 오리지널</h3>
            <p>부드러운 쿠키 속에 쫀득쫀득 찰떡이 들어있는 한국형 퓨전 쿠키</p>
          </div>
        </div>
        <div>
          <div class="photo"><img src="img/유치케 .png" alt="아꾸뿔레" /></div>
          <div class="info">
            <h3>유자치즈케이크</h3>
            <p>치즈케이크의 부드러운 풍미와 상큼한 유자 필링</p>
          </div>
        </div>
        <div>
          <div class="photo">
            <img src="img/쫀득초코.png" alt="쫀득 초코칩" />
          </div>
          <div class="info">
            <h3>쫀득 초코칩</h3>
            <p>부드러운 초코칩 쿠키와 쫄깃한 떡이 만나 인생쿠키 탄생!</p>
          </div>
        </div>
        <div>
          <div class="photo"><img src="img/찰호떡.png" alt="찰호떡쿠키" /></div>
          <div class="info">
            <h3>찰호떡쿠키</h3>
            <p>달~콤한 호떡맛 그대로에 씨앗이 톡톡!</p>
          </div>
        </div>
        <div>
          <div class="photo"><img src="img/브루느와.png" alt="브루느와" /></div>
          <div class="info">
            <h3>브루느와</h3>
            <p>홈메이드풍으로 만든 쫀득한 브라우니 초코칩 쿠키</p>
          </div>
        </div>
        <div>
          <div class="photo">
            <img src="img/그랑쉘 파인애플.png" alt="그랑쉘 파인애플" />
          </div>
          <div class="info">
            <h3>그랑쉘 파인애플</h3>
            <p>달콤상큼한 파인애플 쨈이 톡톡!</p>
          </div>
        </div>
        <div>
          <div class="photo"><img src="img/쫀과.png" alt="쫀득과일칩" /></div>
          <div class="info">
            <h3>쫀득과일칩</h3>
            <p>부드러운 쿠키에 달콤상콤한 과일칩이 콕콕</p>
          </div>
        </div>
        <div>
          <div class="photo">
            <img src="img/그랑쉘 딸기 누끼.png" alt="그랑쉘 딸기" />
          </div>
          <div class="info">
            <h3>그랑쉘 딸기</h3>
            <p>달콤상큼한 딸기와 부드러운 쿠키가 어우러진 그랑쉘 딸기</p>
          </div>
        </div>
        <div>
          <div class="photo">
            <img src="img/그랑쉘 사과1.png" alt="그랑쉘 사과" />
          </div>
          <div class="info">
            <h3>그랑쉘사과</h3>
            <p>과일과즙과 부드러운 쿠키가 어우러져 달콤상큼한 그랑쉘 쿠키</p>
          </div>
        </div>
      </div>
    </div>

    <script>
      // ===== 튜닝 파라미터 =====
      const SCALE = 1.2; // 원 반지름 배율(원 크기)
      const CENTER_OFFSET = 80; // 중심을 위로(픽셀). 클수록 더 위
      const MAX_SCALE = 1.06; // 윗카드 살짝 확대 연출
      const SAFE_PAD = 12; // 위여유(px)

      const wrap = document.getElementById("wrap");
      const wheel = document.getElementById("wheel");
      const items = [...wheel.children];
      // 오프셋 전용 래퍼
      const offsetter = document.createElement("div");
      Object.assign(offsetter.style, {
        position: "relative",
        width: "fit-content",
        margin: "0 auto",
        willChange: "transform",
      });
      wrap.appendChild(offsetter);
      offsetter.appendChild(wheel);

      // 기본 수동 오프셋(필요 없으면 0)
      let X_BASE = 0; // 왼쪽(-), 오른쪽(+)
      let X_EXTRA = 0; // 자동 가운데정렬이 계산해서 넣는 오프셋

      function applyOffset() {
        offsetter.style.transform = `translateX(${X_BASE + X_EXTRA}px)`;
      }

      let base = 0,
        start = 0,
        dragging = false;

      function setWheelSize() {
        const R = wrap.clientHeight * SCALE; // 이상적 반지름

        // 원 크기 설정
        wheel.style.width = R * 2 + "px";
        wheel.style.height = R * 2 + "px";

        // ⬇️ 가로 중앙은 CSS margin:auto가 보장 (absolute 안 씀)
        // 세로 위치는 margin-top으로 조정(양수 = 아래로)
        const mt = wrap.clientHeight - R - CENTER_OFFSET; // 기본 위치에서 위로 올림
        wheel.style.marginTop = mt + "px";
        const X_SHIFT = -40; // 왼쪽(-), 오른쪽(+)
        wheel.style.transform = `translateX(${X_SHIFT}px)`;

        layout(R);
        autoCenter(); //추가
      }
      function autoCenter() {
        // 아이템들의 좌우 경계(현재 프레임 기준) 측정
        const rectWrap = wrap.getBoundingClientRect();
        let minX = Infinity,
          maxX = -Infinity;

        for (const el of items) {
          const r = el.getBoundingClientRect();
          if (r.width === 0 || r.height === 0) continue;
          if (r.left < minX) minX = r.left;
          if (r.right > maxX) maxX = r.right;
        }
        if (!isFinite(minX) || !isFinite(maxX)) return;

        const bboxCenter = (minX + maxX) / 2; // 호의 가로 중앙
        const wrapCenter = rectWrap.left + rectWrap.width / 2; // 화면 중앙

        // offsetter에 줄 추가 오프셋
        X_EXTRA = Math.round(wrapCenter - bboxCenter);
        applyOffset();
      }

      function layout(R) {
        const n = items.length;
        const step = 360 / n;

        // 카드 실제 높이(확대 고려)로 안전 반지름 계산 → 위쪽 안 잘림
        const itemH = items[0].getBoundingClientRect().height || 300;
        const effectiveR = Math.max(40, R - (itemH * MAX_SCALE) / 2 - SAFE_PAD);

        for (let i = 0; i < n; i++) {
          const a = step * i + base;
          const cos = Math.cos((a * Math.PI) / 180);
          const t = `rotate(${a}deg) translate(${effectiveR}px) rotate(${-a}deg)`;
          const s = 1 + (MAX_SCALE - 1) * cos;
          items[i].style.transform = t + ` scale(${s.toFixed(3)})`;
          items[i].style.zIndex = Math.round(100 + 50 * cos);
        }
      }

      function getAngleFromEvent(e) {
        const rect = wheel.getBoundingClientRect();
        const cx = rect.left + rect.width / 2;
        const cy = rect.top + rect.height / 2;
        const p = e.touches ? e.touches[0] : e;
        return Math.atan2(p.clientY - cy, p.clientX - cx) * (180 / Math.PI);
      }

      // 드래그
      wheel.addEventListener("pointerdown", (e) => {
        dragging = true;
        wheel.setPointerCapture(e.pointerId);
        start = getAngleFromEvent(e) - base;
      });
      wheel.addEventListener("pointermove", (e) => {
        if (!dragging) return;
        base = getAngleFromEvent(e) - start;
        const R = wrap.clientHeight * SCALE;
        layout(R);
      });
      wheel.addEventListener("pointerup", () => (dragging = false));
      wheel.addEventListener("pointercancel", () => (dragging = false));

      // 터치
      wheel.addEventListener(
        "touchstart",
        (e) => {
          dragging = true;
          start = getAngleFromEvent(e) - base;
        },
        { passive: true }
      );
      wheel.addEventListener(
        "touchmove",
        (e) => {
          if (!dragging) return;
          base = getAngleFromEvent(e) - start;
          const R = wrap.clientHeight * SCALE;
          layout(R);
        },
        { passive: true }
      );
      wheel.addEventListener(
        "touchend",
        () => {
          dragging = false;
        },
        { passive: true }
      );

      window.addEventListener("resize", setWheelSize);
      setWheelSize();
    </script>
  </body>
</html>
